const prisma = require('./db');

function isMissingUserEmailColumnError(error) {
  if (!error || error.code !== 'P2022') {
    return false;
  }

  const column = String(error.meta?.column || '').toLowerCase();
  return column.includes('email');
}

function isUnknownUserEmailFieldError(error) {
  const message = String(error?.message || '').toLowerCase();
  return message.includes('unknown field') && message.includes('email') && message.includes('user');
}

function isMissingUserShirtNumberColumnError(error) {
  if (!error || error.code !== 'P2022') {
    return false;
  }

  const column = String(error.meta?.column || '').toLowerCase();
  return column.includes('shirtnumber');
}

function isUnknownUserShirtNumberFieldError(error) {
  const message = String(error?.message || '').toLowerCase();
  return message.includes('unknown field') && message.includes('shirtnumber') && message.includes('user');
}

function shouldFallbackWithoutEmail(error) {
  return isMissingUserEmailColumnError(error) || isUnknownUserEmailFieldError(error);
}

function shouldFallbackWithoutShirtNumber(error) {
  return isMissingUserShirtNumberColumnError(error) || isUnknownUserShirtNumberFieldError(error);
}

function withNullEmail(items) {
  return items.map((item) => ({
    ...item,
    email: null
  }));
}

function withNullShirtNumber(items) {
  return items.map((item) => ({
    ...item,
    shirtNumber: null
  }));
}

async function findUserByUsername(username) {
  const exactUsername = String(username || '');
  if (!exactUsername) {
    return null;
  }

  return prisma.user.findUnique({
    where: {
      username: exactUsername
    },
    select: {
      id: true,
      username: true,
      passwordHash: true,
      role: true,
      playerCategory: true,
      isActive: true
    }
  });
}

async function findUserById(id) {
  try {
    return await prisma.user.findUnique({
      where: { id }
    });
  } catch (error) {
    if (!shouldFallbackWithoutEmail(error) && !shouldFallbackWithoutShirtNumber(error)) {
      throw error;
    }

    const user = await prisma.user.findUnique({
      where: { id },
      select: {
        id: true,
        username: true,
        role: true,
        playerCategory: true,
        passwordHash: true,
        lastPasswordChangeAt: true,
        isActive: true,
        createdAt: true
      }
    });

    if (!user) {
      return null;
    }

    return {
      ...user,
      email: null,
      shirtNumber: null
    };
  }
}

async function listUsersForManagement() {
  try {
    return await prisma.user.findMany({
      orderBy: { createdAt: 'asc' },
      select: {
        id: true,
        username: true,
        email: true,
        role: true,
        playerCategory: true,
        shirtNumber: true,
        isActive: true,
        createdAt: true,
        lastPasswordChangeAt: true
      }
    });
  } catch (error) {
    if (!shouldFallbackWithoutEmail(error) && !shouldFallbackWithoutShirtNumber(error)) {
      throw error;
    }

    const rows = await prisma.user.findMany({
      orderBy: { createdAt: 'asc' },
      select: {
        id: true,
        username: true,
        role: true,
        playerCategory: true,
        isActive: true,
        createdAt: true,
        lastPasswordChangeAt: true
      }
    });

    return withNullShirtNumber(withNullEmail(rows));
  }
}

async function countUsersByRole(role, excludeUserId = null) {
  return prisma.user.count({
    where: {
      role,
      ...(excludeUserId ? { id: { not: excludeUserId } } : {})
    }
  });
}

async function createManagedUser(input) {
  try {
    return await prisma.user.create({
      data: input,
      select: {
        id: true,
        username: true,
        email: true,
        role: true,
        playerCategory: true,
        shirtNumber: true,
        isActive: true,
        createdAt: true,
        lastPasswordChangeAt: true
      }
    });
  } catch (error) {
    const missingEmail = shouldFallbackWithoutEmail(error);
    const missingShirtNumber = shouldFallbackWithoutShirtNumber(error);
    if (!missingEmail && !missingShirtNumber) {
      throw error;
    }

    const fallbackInput = { ...input };
    if (missingEmail) {
      delete fallbackInput.email;
    }
    if (missingShirtNumber) {
      delete fallbackInput.shirtNumber;
    }

    let row;
    try {
      row = await prisma.user.create({
        data: fallbackInput,
        select: {
          id: true,
          username: true,
          role: true,
          playerCategory: true,
          isActive: true,
          createdAt: true,
          lastPasswordChangeAt: true
        }
      });
    } catch (fallbackError) {
      const fallbackMessage = String(fallbackError?.message || '').toLowerCase();
      if (missingEmail && fallbackMessage.includes('email') && fallbackMessage.includes('argument')) {
        const schemaError = new Error('Databáza nie je zosynchronizovaná so serverom (chýba stĺpec email). Spustite migráciu Prisma na produkčnej DB.');
        schemaError.status = 500;
        throw schemaError;
      }
      throw fallbackError;
    }

    return {
      ...row,
      email: missingEmail ? null : input.email,
      shirtNumber: null
    };
  }
}

async function setUserActiveStatus(id, isActive) {
  try {
    return await prisma.user.update({
      where: { id },
      data: { isActive },
      select: {
        id: true,
        username: true,
        email: true,
        role: true,
        playerCategory: true,
        shirtNumber: true,
        isActive: true,
        createdAt: true,
        lastPasswordChangeAt: true
      }
    });
  } catch (error) {
    if (!shouldFallbackWithoutEmail(error) && !shouldFallbackWithoutShirtNumber(error)) {
      throw error;
    }

    const row = await prisma.user.update({
      where: { id },
      data: { isActive },
      select: {
        id: true,
        username: true,
        role: true,
        playerCategory: true,
        isActive: true,
        createdAt: true,
        lastPasswordChangeAt: true
      }
    });

    return {
      ...row,
      email: null,
      shirtNumber: null
    };
  }
}

async function resetUserPasswordByAdmin(id, passwordHash) {
  try {
    return await prisma.user.update({
      where: { id },
      data: {
        passwordHash,
        lastPasswordChangeAt: null
      },
      select: {
        id: true,
        username: true,
        email: true,
        role: true,
        playerCategory: true,
        shirtNumber: true,
        isActive: true,
        createdAt: true,
        lastPasswordChangeAt: true
      }
    });
  } catch (error) {
    if (!shouldFallbackWithoutEmail(error) && !shouldFallbackWithoutShirtNumber(error)) {
      throw error;
    }

    const row = await prisma.user.update({
      where: { id },
      data: {
        passwordHash,
        lastPasswordChangeAt: null
      },
      select: {
        id: true,
        username: true,
        role: true,
        playerCategory: true,
        isActive: true,
        createdAt: true,
        lastPasswordChangeAt: true
      }
    });

    return {
      ...row,
      email: null,
      shirtNumber: null
    };
  }
}

async function updateUserRoleAndCategory(id, email, role, playerCategory, shirtNumber) {
  try {
    return await prisma.user.update({
      where: { id },
      data: {
        email,
        role,
        playerCategory,
        shirtNumber
      },
      select: {
        id: true,
        username: true,
        email: true,
        role: true,
        playerCategory: true,
        shirtNumber: true,
        isActive: true,
        createdAt: true,
        lastPasswordChangeAt: true
      }
    });
  } catch (error) {
    const missingEmail = shouldFallbackWithoutEmail(error);
    const missingShirtNumber = shouldFallbackWithoutShirtNumber(error);
    if (!missingEmail && !missingShirtNumber) {
      throw error;
    }

    const fallbackData = {
      email,
      role,
      playerCategory,
      shirtNumber
    };
    if (missingEmail) {
      delete fallbackData.email;
    }
    if (missingShirtNumber) {
      delete fallbackData.shirtNumber;
    }

    const row = await prisma.user.update({
      where: { id },
      data: fallbackData,
      select: {
        id: true,
        username: true,
        role: true,
        playerCategory: true,
        isActive: true,
        createdAt: true,
        lastPasswordChangeAt: true
      }
    });

    return {
      ...row,
      email: missingEmail ? null : email,
      shirtNumber: null
    };
  }
}

async function updateUserPassword(id, passwordHash) {
  return prisma.user.update({
    where: { id },
    data: {
      passwordHash,
      lastPasswordChangeAt: new Date()
    }
  });
}

async function listActivePlayers() {
  try {
    return await prisma.user.findMany({
      where: {
        role: 'player',
        isActive: true
      },
      orderBy: [
        { playerCategory: 'asc' },
        { username: 'asc' }
      ],
      select: {
        id: true,
        username: true,
        playerCategory: true,
        shirtNumber: true
      }
    });
  } catch (error) {
    if (!shouldFallbackWithoutShirtNumber(error)) {
      throw error;
    }

    const rows = await prisma.user.findMany({
      where: {
        role: 'player',
        isActive: true
      },
      orderBy: [
        { playerCategory: 'asc' },
        { username: 'asc' }
      ],
      select: {
        id: true,
        username: true,
        playerCategory: true
      }
    });

    return withNullShirtNumber(rows);
  }
}

function playerCategoriesForTrainingCategory(trainingCategory) {
  const map = {
    pripravky: ['pripravka_u9', 'pripravka_u11'],
    ziaci: ['ziaci'],
    dorastenci: ['dorastenci'],
    adults_young: ['adults_young'],
    adults_pro: ['adults_pro']
  };

  return map[trainingCategory] || [];
}

function trainingCategoriesForPlayerCategory(playerCategory) {
  const map = {
    pripravka_u9: ['pripravky'],
    pripravka_u11: ['pripravky'],
    ziaci: ['ziaci'],
    dorastenci: ['dorastenci'],
    adults_young: ['adults_young'],
    adults_pro: ['adults_pro']
  };

  return map[playerCategory] || [];
}

async function listActivePlayerEmailsByTrainingCategory(trainingCategory) {
  const playerCategories = playerCategoriesForTrainingCategory(trainingCategory);
  if (!playerCategories.length) {
    return [];
  }

  return prisma.user.findMany({
    where: {
      role: 'player',
      isActive: true,
      email: {
        not: null
      },
      playerCategory: {
        in: playerCategories
      }
    },
    orderBy: {
      username: 'asc'
    },
    select: {
      username: true,
      email: true,
      playerCategory: true
    }
  });
}

async function listTrainings(viewerUser) {
  const where = {};

  if (viewerUser?.role === 'coach') {
    where.createdById = viewerUser.id;
  } else if (viewerUser?.role === 'player' || viewerUser?.role === 'parent') {
    const allowedCategories = trainingCategoriesForPlayerCategory(viewerUser.playerCategory);
    if (!allowedCategories.length) {
      return [];
    }

    where.category = {
      in: allowedCategories
    };
  }

  return prisma.training.findMany({
    where,
    orderBy: { createdAt: 'desc' },
    include: {
      createdBy: {
        select: { username: true }
      },
      attendances: {
        select: {
          playerUsername: true,
          status: true,
          updatedAt: true
        }
      }
    }
  });
}

async function findTrainingById(id) {
  return prisma.training.findUnique({
    where: { id }
  });
}

async function createTraining(input, createdById) {
  return prisma.training.create({
    data: {
      ...input,
      createdById
    },
    include: {
      createdBy: {
        select: { username: true }
      }
    }
  });
}

async function closeTraining(id) {
  return prisma.training.update({
    where: { id },
    data: {
      isActive: false
    }
  });
}

async function deleteTraining(id) {
  return prisma.training.delete({
    where: { id }
  });
}

async function upsertTrainingAttendance(trainingId, playerUsername, status, updatedById) {
  return prisma.trainingAttendance.upsert({
    where: {
      trainingId_playerUsername: {
        trainingId,
        playerUsername
      }
    },
    update: {
      status,
      updatedById
    },
    create: {
      trainingId,
      playerUsername,
      status,
      updatedById
    }
  });
}

async function listAnnouncements() {
  return prisma.announcement.findMany({
    orderBy: { createdAt: 'desc' },
    include: {
      createdBy: {
        select: { username: true }
      }
    }
  });
}

async function createAnnouncement(input, createdById) {
  return prisma.announcement.create({
    data: {
      ...input,
      createdById
    },
    include: {
      createdBy: {
        select: { username: true }
      }
    }
  });
}

async function deleteAnnouncement(id) {
  return prisma.announcement.delete({
    where: { id }
  });
}

async function listBlogPosts() {
  if (!prisma.blogPost) {
    throw new Error('Prisma Client neobsahuje model blogPost. Spustite prisma generate a redeploy backendu.');
  }

  return prisma.blogPost.findMany({
    orderBy: { createdAt: 'desc' },
    include: {
      createdBy: {
        select: { username: true }
      }
    }
  });
}

async function createBlogPost(input, createdById) {
  if (!prisma.blogPost) {
    throw new Error('Prisma Client neobsahuje model blogPost. Spustite prisma generate a redeploy backendu.');
  }

  return prisma.blogPost.create({
    data: {
      title: input.title,
      content: input.content,
      published: input.published ?? true,
      createdById
    },
    include: {
      createdBy: {
        select: { username: true }
      }
    }
  });
}

async function findBlogPostById(id) {
  if (!prisma.blogPost) {
    throw new Error('Prisma Client neobsahuje model blogPost. Spustite prisma generate a redeploy backendu.');
  }

  return prisma.blogPost.findUnique({
    where: { id }
  });
}

async function deleteBlogPost(id) {
  if (!prisma.blogPost) {
    throw new Error('Prisma Client neobsahuje model blogPost. Spustite prisma generate a redeploy backendu.');
  }

  return prisma.blogPost.delete({
    where: { id }
  });
}

async function listPolls() {
  return prisma.poll.findMany({
    orderBy: { createdAt: 'desc' },
    include: {
      createdBy: {
        select: { username: true }
      },
      votes: {
        select: {
          optionIdx: true,
          userId: true,
          user: {
            select: { username: true }
          }
        }
      }
    }
  });
}

async function createPoll(input, createdById) {
  return prisma.poll.create({
    data: {
      question: input.question,
      options: input.options,
      target: input.target,
      playerCategory: input.playerCategory,
      closesAt: input.closesAt || null,
      createdById
    },
    include: {
      createdBy: {
        select: { username: true }
      },
      votes: {
        select: {
          optionIdx: true,
          userId: true,
          user: {
            select: { username: true }
          }
        }
      }
    }
  });
}

async function findPollById(id) {
  return prisma.poll.findUnique({
    where: { id }
  });
}

async function deletePoll(id) {
  return prisma.poll.delete({
    where: { id }
  });
}

async function closePoll(id) {
  return prisma.poll.update({
    where: { id },
    data: {
      active: false,
      closedAt: new Date()
    }
  });
}

async function upsertPollVote(pollId, userId, optionIdx) {
  return prisma.pollVote.upsert({
    where: {
      pollId_userId: {
        pollId,
        userId
      }
    },
    update: {
      optionIdx
    },
    create: {
      pollId,
      userId,
      optionIdx
    }
  });
}

async function createAuditLog(input) {
  return prisma.auditLog.create({
    data: input
  });
}

module.exports = {
  findUserByUsername,
  findUserById,
  listUsersForManagement,
  countUsersByRole,
  createManagedUser,
  setUserActiveStatus,
  resetUserPasswordByAdmin,
  updateUserRoleAndCategory,
  updateUserPassword,
  listActivePlayers,
  listActivePlayerEmailsByTrainingCategory,
  listTrainings,
  findTrainingById,
  createTraining,
  closeTraining,
  deleteTraining,
  upsertTrainingAttendance,
  listAnnouncements,
  createAnnouncement,
  deleteAnnouncement,
  listBlogPosts,
  createBlogPost,
  findBlogPostById,
  deleteBlogPost,
  listPolls,
  createPoll,
  findPollById,
  closePoll,
  deletePoll,
  upsertPollVote,
  createAuditLog
};